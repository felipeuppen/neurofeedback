<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Conectar Muse</title>
    <script defer src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script defer src="https://raw.githubusercontent.com/felipeuppen/neurofeedback/main/neurofeedback.js"></script>
    <script defer src="https://c86405ffad19a6265b95230b2818f733.cdn.bubble.io/f1712687056037x412629362840832640/Muse.js"></script>
    <script defer>
        console.log("main.js has been loaded.");
        
        const FFT_SIZE = 64; // Asegúrate de que FFT_SIZE está definido
        let eegBuffer = [];

        class FFT {
            constructor(size, sampleRate) {
                this.size = size;
                this.sampleRate = sampleRate;
                this.real = new Array(size).fill(0);
                this.imag = new Array(size).fill(0);
            }

            forward(buffer) {
                this.real = buffer.slice();
                this.imag.fill(0);

                const N = this.size;
                const halfN = N / 2;
                let real, imag, tpreal, tpimag, costp, sintp;
                let cos = Math.cos, sin = Math.sin, PI = Math.PI;

                for (let i = 0; i < N; i++) {
                    let j = 0;
                    for (let bit = 0; bit < Math.log2(N); bit++) {
                        j = (j << 1) | (1 & (i >> bit));
                    }
                    if (j > i) {
                        [this.real[i], this.real[j]] = [this.real[j], this.real[i]];
                        [this.imag[i], this.imag[j]] = [this.imag[j], this.imag[i]];
                    }
                }

                for (let i = 1; i < N; i <<= 1) {
                    costp = cos(PI / i);
                    sintp = sin(PI / i);

                    for (let j = 0; j < N; j += (i << 1)) {
                        real = 1;
                        imag = 0;

                        for (let k = 0; k < i; k++) {
                            tpreal = real * this.real[j + k + i] - imag * this.imag[j + k + i];
                            tpimag = real * this.imag[j + k + i] + imag * this.real[j + k + i];

                            this.real[j + k + i] = this.real[j + k] - tpreal;
                            this.imag[j + k + i] = this.imag[j + k] - tpimag;

                            this.real[j + k] += tpreal;
                            this.imag[j + k] += tpimag;

                            tpreal = real * costp - imag * sintp;
                            imag = real * sintp + imag * costp;
                            real = tpreal;
                        }
                    }
                }
            }

            get spectrum() {
                const spectrum = new Array(this.size / 2);
                for (let i = 0; i < this.size / 2; i++) {
                    spectrum[i] = Math.sqrt(this.real[i] ** 2 + this.imag[i] ** 2);
                }
                return spectrum;
            }
        }

        class MovingAverage {
            constructor(size) {
                this.size = size;
                this.buffer = new Array(size).fill(0);
            }

            filter(value) {
                this.buffer.shift();
                this.buffer.push(value);
                return this.buffer.reduce((acc, val) => acc + val, 0) / this.size;
            }
        }

        class HighPassFilter {
            constructor(sampleRate, cutoffFrequency) {
                this.sampleRate = sampleRate;
                this.cutoffFrequency = cutoffFrequency;
                this.alpha = this.calculateAlpha(cutoffFrequency, sampleRate);
                this.prevX = 0;
                this.prevY = 0;
            }

            calculateAlpha(cutoffFrequency, sampleRate) {
                const RC = 1.0 / (cutoffFrequency * 2 * Math.PI);
                const dt = 1.0 / sampleRate;
                return dt / (RC + dt);
            }

            filter(x) {
                const y = this.alpha * (x - this.prevX) + (1 - this.alpha) * this.prevY;
                this.prevX = x;
                this.prevY = y;
                return y;
            }
        }

        class LowPassFilter {
            constructor(sampleRate, cutoffFrequency) {
                this.sampleRate = sampleRate;
                this.cutoffFrequency = cutoffFrequency;
                this.alpha = this.calculateAlpha(cutoffFrequency, sampleRate);
                this.prevY = 0;
            }

            calculateAlpha(cutoffFrequency, sampleRate) {
                const RC = 1.0 / (cutoffFrequency * 2 * Math.PI);
                const dt = 1.0 / sampleRate;
                return dt / (RC + dt);
            }

            filter(x) {
                const y = (1 - this.alpha) * x + this.alpha * this.prevY;
                this.prevY = y;
                return y;
            }
        }

        function sumPower(data, startFreq, endFreq) {
            const startIndex = Math.floor(startFreq / (256 / FFT_SIZE));
            const endIndex = Math.floor(endFreq / (256 / FFT_SIZE));
            console.log(`Sumando potencia para frecuencias entre ${startFreq} y ${endFreq}, índices ${startIndex} a ${endIndex}`);
            return data.slice(startIndex, endIndex + 1).reduce((acc, val) => acc + val, 0);
        }

        function updateNeurofeedback(frequencies) {
            if (!frequencyChart) {
                console.error("El gráfico de frecuencias no ha sido inicializado.");
                return;
            }

            const totalPower = frequencies.reduce((a, b) => a + b, 0);
            console.log("Potencia total:", totalPower);

            const deltaPower = sumPower(frequencies, 0.5, 4) / totalPower;
            const thetaPower = sumPower(frequencies, 4, 8) / totalPower;
            const alphaPower = sumPower(frequencies, 8, 14) / totalPower;
            const betaPower = sumPower(frequencies, 14, 30) / totalPower;
            const gammaPower = sumPower(frequencies, 30, 50) / totalPower;

            console.log("Potencias calculadas - Delta:", deltaPower, "Theta:", thetaPower, "Alpha:", alphaPower, "Beta:", betaPower, "Gamma:", gammaPower);

            document.getElementById('deltaPower').textContent = `Delta: ${(deltaPower * 100).toFixed(2)}%`;
            document.getElementById('thetaPower').textContent = `Theta: ${(thetaPower * 100).toFixed(2)}%`;
            document.getElementById('alphaPower').textContent = `Alpha: ${(alphaPower * 100).toFixed(2)}%`;
            document.getElementById('betaPower').textContent = `Beta: ${(betaPower * 100).toFixed(2)}%`;
            document.getElementById('gammaPower').textContent = `Gamma: ${(gammaPower * 100).toFixed(2)}%`;

            const powerData = [
                deltaPower * 100,
                thetaPower * 100,
                alphaPower * 100,
                betaPower * 100,
                gammaPower * 100
            ];

            console.log("Power Data:", powerData);

            frequencyChart.data.datasets[0].data = powerData;
            console.log("Datos actualizados en el gráfico de frecuencias:", frequencyChart.data.datasets[0].data);
            frequencyChart.update();
        }

        var selectedElectrodeIndex = 2;

        function selectElectrodeFP1() {
            setSelectedElectrode(1);
        }

        function selectElectrodeFP2() {
            setSelectedElectrode(2);
        }

        function selectElectrodeTP9() {
            setSelectedElectrode(0);
        }

        function selectElectrodeTP10() {
            setSelectedElectrode(3);
        }

        function setSelectedElectrode(index) {
            selectedElectrodeIndex = index;
            console.log("Electrode seleccionado cambiado a: " + index);
        }

        var amplitudeScale = 512;

        var muse;
        var updateIntervals = [];
        var lpFilter = new LowPassFilter(256, 50);
        var filtersEnabled = true;

        async function connectAndReadData() {
            console.log("connectAndReadData function called.");
            try {
                muse = new Muse();
                await muse.connect();
                document.getElementById('connect').style.display = 'none';
                document.getElementById('disconnect').style.display = 'inline';
                console.log("Conectado exitosamente.");
                bubble_fn_MuseStatus("connected");
                adjustAmplitudeScale(512);
                updateIntervals.push(setInterval(updateBatteryLevel, 1000));
                updateIntervals.push(setInterval(readEEGData, 100));
            } catch (error) {
                console.error("Error in connectAndReadData:", error);
            }
        }

        function disconnect() {
            if (muse) {
                muse.disconnect();
                console.log("Desconectado exitosamente.");
                document.getElementById('disconnect').style.display = 'none';
                document.getElementById('connect').style.display = 'inline';
                bubble_fn_MuseStatus("disconnected");
                updateIntervals.forEach(clearInterval);
                updateIntervals = [];
            }
        }

        function updateBatteryLevel() {
            if (muse && muse.batteryLevel != null) {
                document.getElementById("batteryLevel").innerText = "Nivel de batería: " + muse.batteryLevel.toFixed(2) + "%";
                bubble_fn_MuseBattery(muse.batteryLevel.toFixed(2));
            }
        }

        function toggleFilters() {
            filtersEnabled = document.getElementById('enableFilters').checked;
        }

        function readEEGData() {
            try {
                let eegValue = muse.eeg[selectedElectrodeIndex].read();
                if (eegValue !== null) {
                    let filteredValue = filtersEnabled ? lpFilter.filter(eegValue) : eegValue;
                    filteredValue = Math.max(filteredValue, -400);
                    document.getElementById("eegFP1").innerText = "Electrode " + selectedElectrodeIndex + ": " + Math.abs(filteredValue).toFixed(2) + " uVrms";
                    processEEGData(Math.abs(filteredValue));
                    addToRecording(Math.abs(filteredValue));
                    bubble_fn_voltage(filteredValue);
                    updateVoltageGraph(filteredValue);
                }
            } catch (error) {
                console.error("Error in readEEGData:", error);
            }
        }

        function adjustAmplitudeScale(newScale) {
            amplitudeScale = 500 / newScale;
            document.getElementById('scaleValue').innerText = `${newScale.toFixed(1)}x`;
        }

        document.getElementById('amplitudeScale').addEventListener('input', function() {
            adjustAmplitudeScale(this.valueAsNumber);
        });

        window.connectAndReadData = connectAndReadData;
        window.disconnect = disconnect;
        window.toggleFilters = toggleFilters;
        window.readEEGData = readEEGData;
        window.adjustAmplitudeScale = adjustAmplitudeScale;

        window.processEEGData = function(uVrms) {
            console.log("processEEGData called with:", uVrms);
            eegBuffer.push(uVrms);
            console.log("eegBuffer length:", eegBuffer.length);
            if (eegBuffer.length >= FFT_SIZE) {
                console.log("Buffer lleno, calculando FFT...");
                const fft = new FFT(FFT_SIZE, 256);
                fft.forward(eegBuffer);
                const frequencies = fft.spectrum;
                console.log("Frequencies calculated:", frequencies);
                updateNeurofeedback(frequencies);
                eegBuffer = eegBuffer.slice(-FFT_SIZE / 2); // Desplazar la ventana a la mitad para una actualización continua
            }
        };

        console.log("All functions have been registered globally.");

        window.onload = function() {
            console.log("Window loaded. Checking if functions are defined...");
            console.log("connectAndReadData:", typeof connectAndReadData);
            console.log("disconnect:", typeof disconnect);

            document.getElementById('connect').addEventListener('click', function() {
                if (typeof connectAndReadData === 'function') {
                    connectAndReadData();
                } else {
                    console.error("connectAndReadData is not defined.");
                }
            });

            document.getElementById('disconnect').addEventListener('click', function() {
                if (typeof disconnect === 'function') {
                    disconnect();
                } else {
                    console.error("disconnect is not defined.");
                }
            });
        };

        const dataPoints = Array(26).fill(null);
        const timePoints = Array.from({length: 26}, (_, i) => i * 120);

const ctx = document.getElementById('voltageGraph').getContext('2d');
const voltageChart = new Chart(ctx, {
    type: 'line',
    data: {
        labels: timePoints,
        datasets: [{
            label: 'Voltaje',
            backgroundColor: 'rgba(131, 89, 121, 0.2)',
            borderColor: '#4666FF',
            data: dataPoints,
            spanGaps: true,
            pointRadius: 0
        }]
    },
    options: {
        scales: {
            x: {
                type: 'linear',
                min: 0,
                max: 3000,
                ticks: {
                    stepSize: 120
                }
            },
            y: {
                min: -400,
                max: 400
            }
        },
        plugins: {
            legend: {
                display: false
            }
        }
    }
});


        function updateVoltageGraph(newValue) {
            dataPoints.shift();
            dataPoints.push(newValue);
            voltageChart.update();
        }

const frequencyCtx = document.getElementById('frequencyGraph').getContext('2d');
const frequencyChart = new Chart(frequencyCtx, {
    type: 'bar',
    data: {
        labels: ['Delta', 'Theta', 'Alpha', 'Beta', 'Gamma'],
        datasets: [{
            label: 'Frecuencia',
            backgroundColor: (ctx) => {
                const index = ctx.dataIndex;
                const colors = [
                    'rgba(254, 224, 144, 0.6)', 
                    'rgba(253, 174, 97, 0.6)', 
                    'rgba(244, 109, 67, 0.6)', 
                    'rgba(213, 62, 79, 0.6)', 
                    'rgba(158, 1, 66, 0.6)'
                ];
                return colors[index];
            },
            borderColor: (ctx) => {
                const index = ctx.dataIndex;
                const colors = [
                    'rgba(254, 224, 144, 1)', 
                    'rgba(253, 174, 97, 1)', 
                    'rgba(244, 109, 67, 1)', 
                    'rgba(213, 62, 79, 1)', 
                    'rgba(158, 1, 66, 1)'
                ];
                return colors[index];
            },
            data: [0, 0, 0, 0, 0]
        }]
    },
    options: {
        scales: {
            x: {
                beginAtZero: true
            },
            y: {
                min: 0,
                max: 100
            }
        },
        plugins: {
            legend: {
                display: false
            }
        }
    }
});


        function updateFrequencyGraph(data) {
            frequencyChart.data.datasets[0].data = data;
            frequencyChart.update();
        }

        function showVoltageGraph() {
            document.getElementById('voltageGraphContainer').style.display = 'block';
            document.getElementById('frequencyGraphContainer').style.display = 'none';
        }

        function showFrequencyGraph() {
            document.getElementById('voltageGraphContainer').style.display = 'none';
            document.getElementById('frequencyGraphContainer').style.display = 'block';
        }
    </script>
</head>
<body>
    <div id="relaxedTime">Tiempo Relajado: 0 segundos</div>
    <div id="attentiveTime">Tiempo Atento: 0 segundos</div>
    <div id="neutralTime">Tiempo Neutro: 0 segundos</div>
    <button onclick="selectElectrodeFP1()">Select FP1</button>
    <button onclick="selectElectrodeFP2()">Select FP2</button>
    <button onclick="selectElectrodeTP9()">Select TP9</button>
    <button onclick="selectElectrodeTP10()">Select TP10</button>

    <audio id="neurofeedbackAudio" preload="auto" src="https://c86405ffad19a6265b95230b2818f733.cdn.bubble.io/f1694387578210x547236694268484700/Her%20Beautiful%20Hairs.mp3"></audio>

    <div>
        <input type="checkbox" id="enableFilters" checked>
        <label for="enableFilters">Habilitar Filtros</label>
    </div>

    <button id="connect">Conectar y Leer Datos</button>
    <button id="disconnect" style="display:none;">Desconectar</button>
    <div id="batteryLevel">Nivel de batería: --%</div>
    <div id="eegData">
        <div id="eegFP1">FP1: --</div>
    </div>
    <div>
        <label for="showYAxisLegend">Mostrar leyenda del eje Y:</label>
        <select id="showYAxisLegend">
            <option value="true">Sí</option>
            <option value="false" selected>No</option>
        </select>
    </div>

    <div>
        <label for="amplitudeScale">Escala de Amplitud:</label>
        <input type="range" id="amplitudeScale" min="1" max="1500" value="512" step="1">
        <span id="scaleValue"></span>
    </div>

    <div id="warningMessage"></div>

    <button onclick="showVoltageGraph()">Mostrar Gráfico de Voltaje</button>
    <button onclick="showFrequencyGraph()">Mostrar Gráfico de Frecuencia</button>

    <div id="voltageGraphContainer" style="display:none;">
        <canvas id="voltageGraph"></canvas>
    </div>

    <div id="frequencyGraphContainer" style="display:none;">
        <canvas id="frequencyGraph"></canvas>
    </div>

    <div id="frequencyValues">
        <p id="deltaPower">Delta: --%</p>
        <p id="thetaPower">Theta: --%</p>
        <p id="alphaPower">Alpha: --%</p>
        <p id="betaPower">Beta: --%</p>
        <p id="gammaPower">Gamma: --%</p>
    </div>
</body>
</html>
